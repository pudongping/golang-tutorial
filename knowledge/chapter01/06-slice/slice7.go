/**
map 和 slice 是非线性安全的

你会发现无论你执行多少次，每次输出的值大概率都不会一样。也就是追加进 slice 的值，出现了覆盖的情况。
因此在循环中所追加的数量，与最终的值并不相等。且这种情况，是不会报错的，是一个出现率不算高的隐式的问题。
这个产生的主要原因是程序逻辑本身就有问题，同时读取到相同索引位，自然也就会产生覆盖的写入了。
*/
package main

import (
	"fmt"
)

func main() {
	var s []int

	for i := 0; i < 30; i++ {
		go func(ri int) {
			i := ri
			s = append(s, i)
			fmt.Printf("走到哪儿了 %d 此时切片的长度是多少 ====> %d \n", i, len(s))
		}(i)

		fmt.Printf("多少了 ====> %d \n", len(s))
	}

	fmt.Printf("总的切片长度是多少 ====> %d \n", len(s))

}

/**
多少了 ====> 0
多少了 ====> 1
多少了 ====> 1
多少了 ====> 1
多少了 ====> 1
多少了 ====> 2
多少了 ====> 2
走到哪儿了 0 此时切片的长度是多少 ====> 1
多少了 ====> 2
走到哪儿了 2 此时切片的长度是多少 ====> 4
走到哪儿了 7 此时切片的长度是多少 ====> 3
走到哪儿了 4 此时切片的长度是多少 ====> 5
多少了 ====> 5
走到哪儿了 3 此时切片的长度是多少 ====> 7
走到哪儿了 1 此时切片的长度是多少 ====> 2
多少了 ====> 8
多少了 ====> 8
走到哪儿了 9 此时切片的长度是多少 ====> 9
走到哪儿了 10 此时切片的长度是多少 ====> 11
走到哪儿了 11 此时切片的长度是多少 ====> 10
多少了 ====> 9
多少了 ====> 11
多少了 ====> 11
多少了 ====> 11
多少了 ====> 11
多少了 ====> 11
多少了 ====> 11
多少了 ====> 11
多少了 ====> 11
多少了 ====> 12
多少了 ====> 12
多少了 ====> 9
多少了 ====> 9
多少了 ====> 17
多少了 ====> 17
多少了 ====> 17
多少了 ====> 17
多少了 ====> 17
多少了 ====> 17
总的切片长度是多少 ====> 17
*/
